---
layout: post
title: 'day27笔记-OSI七层模型, 协议, IP, 域名, 端口, 传输层服务, python网络通信(服务端, 客户端)'
description: PythonNet
tag: 博客  
---   
吕泽  [lvze@tedu.cn](lvze@tedu.cn)
### 课程安排和特点
    1. 网络编程(4天)
    2. 进程线程(5天)
    3. MongDB 数据库(4天)
    4. 正则表达式(1天)
    5. 项目(2.5天)
    6. git的使用(1天)

### 网络编程
    网络功能: 数据传输
    ISO(国家标准化组织)

    OSI七层模型 --> 网络通信工作流程的标准化

### OSI七层模型
    应用层: 提供用户服务, 具体功能由特定的程序而定
    表示层: 数据的压缩优化, 加密
    会话层: 建立应用级的连接, 选择传输服务
    传输层: 提供不同的传输服务, 流量控制
    网络层: 路由选择, 网络互连
    链路层: 进行数据转换, 具体消息的发送, 链路连接
    物理层(基层): 物理硬件, 接口设定, 网卡路由交换机等

    优点:
      1. 将工作流程标准化
      2. 降低了模块之间的耦合度, 使每一部分可以单独开发, 单独工作

高内聚: 模块功能尽可能单一, 不要掺杂
<p>
低耦合: 模块之间尽可能减少关联和影响</p>

### 四层模型
    应用层: 应用层, 表示层, 会话层
    传输层
    网络层
    物理链路层

### 五层模型(TCP/IP模型)
    应用层: 应用层, 表示层, 会话层
    传输层
    网络层
    链路层
    物理层

### 数据传输流程
    1. 发送端由应用层到物理层逐层添加信息头(首部), 最终在物理层发送
    2. 中间经过节点(交换机, 路由器等)转发, 发送到接收端
    3. 在接收端根据发送端的每个信息头进行解析,最终消息到应用层展示给用户

### 协议
    网络协议: 在网络通信中双方都遵循的规定
      包括建立什么样的网络结构, 消息结构, 标识代表什么等

    应用层: TFTP  HTTP  DNS  SMTP
    传输层: TCP  UDP
    网络层: IP
    物理层: IEEE

### 网络相关概念
    网络主机: 在网络中标识一台计算机  HOST
    本地使用: 'localhost', '127.0.0.1'
    网络使用: '0.0.0.0'(网卡自动分配), '10.8.44.116'(本机IP)
    注: 0.0.0.0 可以被所有人访问本机IP也可以被自己用本地IP访问
    获取计算机名:
      ipython3
      In [1]: import socket
      In [2]: socket.gethostname()
      Out[2]: 'tedu'
      In [3]: socket.gethostbyname('tedu')
      Out[3]: '127.0.1.1'

### IP地址
    网络上确定一台主机网络位置的地址
    IPv4: 点分十进制  192.168.0.1  0~255  最大32位
    Ipv6: 128位
    公网 IP唯一
    ping ip: 测试和某台主机是否联通
    特殊IP地址:
      127.0.0.1      本地测试IP
      0.0.0.0        本机可用IP
      192.168.1.0    网段IP
      192.168.1.1    网关IP
      192.168.1.255  广播地址

    通过地址获取知己网络信息
      In [1]: socket.gethostbyaddr('localhost')
      Out[1]: ('localhost', [], ['127.0.0.1'])
                  主机名    别名     网络地址

    点分十进制地址转换为二进制
      In [5]: socket.inet_aton('192.168.1.2')
      Out[5]: b'\xc0\xa8\x01\x02'
    二进制地址转换为点分十进制
      In [7]: socket.inet_ntoa(b'\xc0\xa8\x01\x02')
      Out[7]: '192.168.1.2'

### 域名
    网络服务器地址的名称
    1. 方便记忆
    2. 名称表达一定的含义

### 网络端口号
    端口号是网络地址的一部分, 用于区分一个网络主机上的网络应用
    * 在一个操作系统中不同的网络应用监听不同的端口号
    取值范围: 1~65535
      1~255  一些众所周知的通用端口
      256~1023  系统应用端口
      1024~65535  自用端口
      建议使用 > 10000的端口
    获取一个应用的端口信息
      In [11]: socket.getservbyname('mysql')
      Out[11]: 3306
      In [16]: socket.getservbyname('https')
      Out[16]: 443

网络字节序: 数据在网络中的传输格式
### 传输层服务
    面向连接的传输服务
      基于 tcp协议 的数据传输
      传输特点:
        提供可靠的数据传输, 指数据传输过程中无丢失, 无失序, 无差错, 无重复
      实现手段:
        数据传输断开前都需要进行传输和断开的确认
      三次握手:
        tcp传输在数据传输前建立连接的过程
        1. 客户端向服务器发送连接请求
        2. 服务器收到请求后回复确认消息, 表示允许连接
        3. 客户端收到服务器回复, 进行最终标志发送确认连接
      四次挥手:
        tcp传输在连接断开前进行断开确认的过程
        1. 主动方发送报文告知被动方要断开连接
        2. 被动方收到请求后立即返回报文告知已经准备断开
        3. 被动发准备就绪后再次发送报文告知可以断开
        4. 主动方发送消息, 确认最终断开

      应用情况:
        适用于传输较大的文件, 网络情况良好, 需要保证传输可靠性的情况
      比如: 网页的获取, 文件下载, 邮件传输, 登录注册

    面向无连接的传输服务
      基于 udp协议 的数据传输
      传输特点:
        不保证传输的可靠性, 传输过程没有连接和断开的流程, 数据收发自由
      使用情况:
        网络情况较差, 对传输可靠性要求不高, 需要提升传输效率, 不便连接, 需要灵活收发消息
      比如: 网络视频, 群聊, 广播发送

### 要求
    1. OSI七层模型介绍一下, TCP/IP模型呢
    2. tcp服务和udp服务有什么区别
    3. 三次握手和四次挥手是什么意思, 过程是怎么样的

### python实现网络通信
    socket套接字编程
      目标:
        根据socket模块提供的接口函数, 进行组合使用, 完成基于tcp或udp的网络编程
      套接字:
        完成上述目标的一种编程手段, 编程方案
      套接字分类:
        流式套接字(SOCK_STREAM):
          传输层基于tcp协议的套接字编程方案
        数据报套接字(SOCK_DGRAM):
          传输层基于udp协议的套接字编程方案
        底层套接字(SOCK_RAM):
          访问底层协议的套接字编程

      * 面向连接传输 -- tcp协议 -- 可靠 -- 流式套接字
      * 面向无连接传输 -- udp协议 -- 不可靠 -- 数据报套接字

### tcp套接字服务端
    import socket
    # 1. 创建套接字
    sockfd = socket.socket(sock_family = AF_INET,
                           socket_type = SOCK_STREAM,
                           proto = 0)

    功能: 创建套接字
    参数:
      socket_family: 选择地址族类型 AF_INET(IPv4)
      socket_type: 套接字类型 SOCK_STREAM 流式
                            SOCK_DGRAM 数据报
      proto: 选择子协议类型 通常为0
    返回值: 返回套接字对象

    # 2. 绑定服务端地址
    sockfd.bind()

    功能: 绑定IP地址
    参数: 元组(ip, port)

    # 3. 设置监听套接字(仅tcp套接字)
    sockfd.listen(n)

    功能: 将套接字设置为监听套接字, 创建监听队列
    参数: n 表示监听队列大小
    * 一个监听套接字可以连接多个客户端套接字

    # 4. 等待处理客户端连接请求
    connfd, addr = sockfd.accept()

    功能: 阻塞等待处理客户端连接
    返回值: connfd 客户端连接套接字
           addr   连接的客户端地址
    * 阻塞函数:
      程序运行过程中遇到阻塞函数则暂定运行, 直到某种阻塞条件达成再继续运行

    # 5. 消息收发
    data = connfd.recv(buffersize)

    功能: 接受对应客户端消息
    参数: 一次最多接收多少字节
    返回值: 接收到的内容
    * 如果没有消息则会阻塞

    n = connfd.send(data)

    功能: 发送消息给对应客户端
    参数: 要发送的内容, 必须是bytes格式
    返回值: 返回实际发送消息的大小

    # 6. 关闭套接字
    sockfd.close()

    功能: 关闭套接字

### 最基本服务端程序
    # tcp_server.py
    from socket import *

    # 创建套接字
    sockfd = socket(AF_INET, SOCK_STREAM)

    # 绑定地址
    sockfd.bind(('0.0.0.0', 8888))

    # 设置监听
    sockfd.listen(5)

    # 等待接受连接
    print('Waiting for connect...')
    connfd, addr = sockfd.accept()
    print('Connect from', addr)

    while True:
        # 收发消息
        data = connfd.recv(1024)
        if data == b"##":
            break
        print(data.decode())
        n = connfd.send(b'Receive your message')
        print("发送了%d字节" % n)  # send返回值

    # 关闭套接字
    connfd.close()
    sockfd.close()

### tcp套接字客户端
    # 1. 创建套接字
    * 必须相同类型的套接字才能通信
    # 2. 建立连接
    sockfd.connect(server_addr)

    功能: 建立连接
    参数: 元组, 服务器地址

    # 3. 消息收发
    * 消息收发要和服务端配合, 避免两边都出现recv阻塞

    # 4. 关闭套接字

### 最基本的客户端程序
    # tcp_client.py
    from socket import *

    # 创建套接字
    sockfd = socket(AF_INET, SOCK_STREAM)

    # 建立连接
    server_addr = ('127.0.0.1', 9999)
    sockfd.connect(server_addr)

    while True:
        # 消息发送接收
        data = input('发送>>')
        sockfd.send(data.encode())
        if data == "##":
            break
        data = sockfd.recv(1024)
        print("接收到:", data.decode())

    # 关闭套接字
    sockfd.close()

### 每日练习
    1. 总结口述方案
      OIS七层模型和tcp/ip模型
      三次握手和四次挥手过程
      tcp和udp的区别
    2. 将完成的基本的tcp_server改写为一个, 当客户端输入特殊字符退出后可以继续接受
    下个客户端请求的程序
    3. 复习文件的读写seek操作
