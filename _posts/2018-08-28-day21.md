---
layout: post
title: 'day21笔记-'
description: OOP基础
tag: 博客
---   
## day20 回顾
### 回顾
    封装
      interface
      私有属性和私有方法 (类内以双下划'__'线开头的标识符)
    多态
      动态(python只能实现动态)
      静态
    多继承(尽量不用)
      class MigrantWorker(Peasant, Worker):
          pass

      MRO (Method Resolution Order)
      Tank.__mro__
    函数重写
      在自定义的类内加入相应的方法可以让自定义类型的对象使用内建函数进行操作

      repr         __repr__(self)
      str          __str__(self)
      abs
      len          __len__(self)
      int
      float
      bool
      next()
      iter()
      ...

    迭代器(高级)
      iter(obj) 返回的对象 obj.__iter__() 返回
      next(it) 取值 it.__iter__()

## day21 笔记
### 异常(高级)
    with 语句
      语法:
        with 表达式1 [as 变量1], 表达式 [as 变量2], ...:
            语句块
      作用:
        使用于对资源进行访问的场合, 确保使用过程中不管是否发生异常都会执行必须的'清理'操作, 并释放资源
          如: 文件打开后自动关闭, 线程中锁的自动获取和释放等(线程后面会学)
      说明:
        as 子句中的变量用于绑定表达式执行后生成的对象
        with语句并不会改变异常的状态
      异常相关语句:
        try-except
        try-finally
        raise
        assert
        with
      示例:
        # with.py
        # 第一种方式, 用try-finally保证文件一定能够正常关闭
        try:
            f = open("../day13/day13.txt")
            try:
                for l in f:
                    x = int('aaaa')  # 出现异常
                    print(l)
            finally:
                f.close()
                print('文件已经关闭')
        except OSError:
            print('打开文件失败')


        # 第二种方式, 用with语句
        try:
            with open("../day13/day13.txt") as f:
                for l in f:
                    x = int('aaa')  # 当进入异常流程时, 打开的文件也能被关闭
                    print(l)
        except OSError:
            print('打开文件失败')

### 资源管理器
    1. 类内有__enter__和__exit__实例方法的类创建的对象被称为环境管理器
    2. 能够用with语句进行管理的对象必须是环境管理器
    3. __enter__方法将在进入with语句时被调用, 由as变量绑定返回的对象
    4. __exit__方法将在离开with语句时被自动调用, 且可以通过参数来判断离开with语句时是否有异常发生

    示例:
      # with3.py
      class A:
          '''此类的对象可以用于with语句进行管理'''
          def __enter__(self):
              print('此方法是在with语句内执行的')
              return self  # self将 被 with中的 as变量绑定

          def __exit__(self, exc_type, exc_val, exc_tb):
              '''exc_type 用来绑定错误类型, 当没有异常发生时绑定None
                 exc_val 用来绑定错误对象, 当没有异常发生时绑定None
                 exc_tb 用来绑定Traceback对象, 当没有异常发生时绑定None
              '''
              if exc_type is None:
                  print('您已离开with语句, 离开时未发生任何异常')
              else:
                  print('您已离开with语句')
                  print('错误类型是:', exc_type)
                  print('错误对象是', exc_val)
                  print('Traceback', exc_tb)


      with A() as a:
          print('这是with语句内部输出')
          int(input('请输入整数:'))

      print('程序正常结束')

### 运算符重载
    什么是运算符重载
      让自定义的类生成的对象(实例) 能够使用运算符进行操作
    作用:
      让自定义类的实例像內建对象一样进行运算符操作
      让程序简洁易读
      对自定义对象将运算符赋予新的规则

### 算术运算符的重载
    方法名                       运算符和表达式        说明
    __add__(self, rhs)          self + rhs          加法
    __sub__(self, rhs)          self - rhs          减法
    __mul__(self, rhs)          self * rhs          乘法
    __truediv__(self, rhs)      self / rhs          除法
    __floordiv__(self, rhs)     self // rhs         地板除
    __mod__(self, rhs)          self % rhs          取模(求余)
    __pow__(self, rhs)          self ** rhs         幂运算        

    rhs (right hand side) 右手边
    说明:
      运算符重载方法及参数已经有固定的含义, 不建议改变原有的运算符含义及参数的意义

    示例:
      # mynumber.py
      class MyNumber:
          def __init__(self, v):
              self.data = v

          def __repr__(self):
              return 'MyNumber(%d)' % self.data

          def __add__(self, rhs):
              '''此方法用来制定self + other的规则'''
              v = self.data + rhs.data
              return MyNumber(v)  # 用v创建一个新的对象返回给调用者

          def __sub__(self, rhs):
              v = self.data - rhs.data
              return MyNumber(v)


      n1 = MyNumber(100)
      n2 = MyNumber(200)
      # n3 = n1.__add__(n2)
      n3 = n1 + n2  # 等同于 n3 = n1.__add__(n2)
      print(n3)  # MyNumber(300)
      n4 = n3 - n2  # 等同于 n4 = n3.__sub__(n2)
      print(n4)  # MyNumber(100)

### 二元运算符的重载方法
    格式:
      def __xxx__(self, rhs):
          语句块

### 练习
    实现两个自定义列表的相加
    class MyList:
        def __init__(self, iterable=()):
            self.data = list(iterable)
        ...
    L1 = MyList([1, 2, 3])
    L2 = MyList([4, 5, 6])
    L3 = L1 + L2
    print(L3)  # MyList([1, 2, 3, 4, 5, 6])
    L4 = L2 + L1
    print(L4)  # MyList([4, 5, 6, 1, 2, 3])
    # 试想能否实现以下操作
    L5 = L1 * 3
    print(L5)  # MyList([1, 2, 3, 1, 2, 3, 1, 2, 3])

    答:
    class MyList:
        def __init__(self, iterable=()):
            self.data = list(iterable)

        def __repr__(self):
            return 'MyNumber(%s)' % self.data

        def __add__(self, rhs):
            lst = self.data + rhs.data
            return MyList(lst)

        def __mul__(self, rhs):
            lst = self.data * rhs
            return MyList(lst)


    L1 = MyList([1, 2, 3])
    L2 = MyList([4, 5, 6])
    L3 = L1 + L2
    print(L3)  # MyList([1, 2, 3, 4, 5, 6])
    L4 = L2 + L1
    print(L4)  # MyList([4, 5, 6, 1, 2, 3])
    L5 = L1 * 3
    print(L5)  # MyList([1, 2, 3, 1, 2, 3, 1, 2, 3])
