---
layout: post
title: '算法笔记'
description: 算法
tag: 博客
---  
### 查找算法
    根据指定的值, 在待查找数据集合中确认是否存在某一数据的值与该指定值相同
    1. 顺序查找
      操作:
        从待查找数据的第一个元素开始, 逐个将每个元素与要查找的数据值进行对比; 如果比较到两者值相同, 则查找成功; 如果一直到最后都未找到, 则查找失败
      特点:
        不要求数据本身有序
      劣势:
        当数据集合比较大时, 查找效率低

    2. 二分查找
      操作:
        找出'有序数据'中的中间元素, 由中间元素值将原数据分为两个子表, 然后根据指定查找值与中间元素的大小关系进行比对; 若相同, 则查找成功; 若查找值小于中间元素, 则在左侧子表中继续查找; 若查找值大于中间元素, 则在右侧子表中继续查找. 如此递归查找下去, 直到查找成功或查找完整个数据集合为止. (折半查找)
      优势:
        比较次数少，查找速度快，平均性能好
      劣势:
        要求待查表为有序表，且插入删除困难

### 排序算法
    1. 冒泡排序
      重复走访要排序的数据集合, 依次比较每两个相邻的元素; 如果其次序错误则交换两数据; 重复进行走访对比直到没有相邻数据需要交换为止
      特点: 对数据本身有序性敏感

    2. 插入排序
      将数据插入到已经有序的数据中, 从而得到新的有序数据, 默认首元素自然有序, 取出下一个元素, 对已经排序的数据从后向前扫描; 若有序数据大于取出数据, 则该有序数据后移; 若有序数据小于取出数据, 则在该有序数据后插入取出数据, 如果所有有序数据均大于取出数据, 则在有序数据头部插入取出数据
      取出下一个未排序的数据, 重复以上步骤, 直到处理完毕
      特点: 不交换只移动, 优于冒泡

    3. 快速排序
      首先任意选取一个数据(通常我们选用第一个数)作为关键数据, 然后将所有比它小的数据放在其前面, 将所有比它大的数据放到其后面, 这个过程称为一趟快速排序, 通过一趟排序将数据分为两个部分, 然后递归对该两个部分重复进行快速排序, 以达到所有数据有序
      特点: 如果每次都能均匀分组则排序速度是最快的
